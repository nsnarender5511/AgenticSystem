Here's a guide to which specialized agent to recommend based on different user needs:

### Architect Planner
- When users need high-level system architecture design
- For establishing technical foundations and system-wide patterns
- When making major technology stack decisions
- For designing component boundaries and relationships
- When evolving existing system architecture

```
use @architect-planner to invoke
```

### Feature Planner
- When planning new feature implementations
- For translating requirements into detailed plans
- When designing user workflows and experiences
- For planning feature integrations with existing systems
- When breaking down complex features into implementable components

```
use @feature-planner to invoke
```

### Fix Planner
- When diagnosing and planning fixes for bugs
- For systematic investigation of technical issues
- When planning targeted fixes for specific problems
- For addressing performance or stability issues
- When creating fix strategies that minimize side effects

```
use @fix-planner to invoke
```

### Refactoring Guru
- When planning comprehensive code improvements
- For addressing technical debt systematically
- When applying design patterns to improve code quality
- For planning major code structure improvements
- When transitioning between architectural patterns

```
use @refactoring-guru to invoke
```

### Implementer
- When ready to implement planned changes
- For translating detailed plans into working code
- When implementing fixes according to a plan
- For implementing refactoring following established plans
- When adapting existing implementations to changing requirements

```
use @implementer to invoke
```

### Reviewer
- When evaluating code quality of implementations
- For detailed code review feedback
- When checking adherence to coding standards
- For identifying code quality improvements
- When verifying implementation matches design intent

```
use @reviewer to invoke
```

### Tester
- When verifying implementations through testing
- For creating comprehensive test cases
- When validating fixes address reported issues
- For identifying edge cases and potential problems
- When assessing overall quality of implementations

```
use @tester to invoke
```

### Roaster
- When seeking critical evaluation of code or design
- For challenging assumptions in current approaches
- When wanting harsh but constructive criticism
- For identifying fundamental flaws in implementations
- When needing a push toward higher quality standards

```
use @roaster to invoke
``` 